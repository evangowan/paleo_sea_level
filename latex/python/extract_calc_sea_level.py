#!/usr/bin/env python3

import sys
import csv
import numpy as np
import pandas as pd

# this program extracts calculated sea level from the file "rsl_spreadsheet.dat", which is generated by my fork of SELEN.
# This works differently than the original Fortran program that I made years ago. I changed the calculated sea level
# file so that each row represents the calculated sea level time series at a given longitude and latitude. This actually
# makes the files a lot smaller. The format is:

# longitude latitude time_0 time_1 time_2 ...


# it assumed that this program is run *after* sea_level_indicator_types.py





def closest_point(latitude_array,longitude_array, latitude, longitude):


	def distance(latitude1, longitude1, latitude2, longitude2):

		# Haversine Formula for calculating distance between two points on a sphere

		# checked against this site: https://www.movable-type.co.uk/scripts/latlong.html


		radius_earth = 6371000.0

		phi1 = np.radians(latitude1)
		phi2 = np.radians(latitude2)
		lamda1 = np.radians(longitude1)
		lamda2 = np.radians(longitude2)


		a = np.power(np.sin((phi2-phi1)/2.0),2)+np.cos(phi1) * np.cos(phi2) * np.power(np.sin((lamda2-lamda1)/2.0),2)
		c = 2.0 * np.arctan2(np.sqrt(a), np.sqrt(1.0-a))

		distance = radius_earth * c

		return distance

	distance_array = distance(latitude, longitude, latitude_array, longitude_array)

	closest_distance = 999999999.0
	closest_index = 0

	index = -1

	for distance in distance_array:

		index = index + 1

		if distance < closest_distance:
				closest_distance=distance
				closest_index=index
	
	return closest_distance, closest_index



def find_score(sea_level_curve,data_point):

	def intermediate_elevation(age1, age2, elevation1, elevation2, intermediate_age):
		
		slope = (elevation1 - elevation2) / (age1 - age2)
		intercept = elevation1 - slope * age1

		elevation = slope * intermediate_age + intercept
		return elevation

	score = 0


	old_age = (data_point['median_age'] + data_point['age_uncertainty']) / 1000.0
	young_age = (data_point['median_age'] - data_point['age_uncertainty']) / 1000.0

	data_dict = {'age':'', 'calc_sl':''}

	check_points = []

	number_points = len(sea_level_curve)

	# add points between the age ranges
	for index_number in range(number_points-1):
		if sea_level_curve[index_number]['age'] <= old_age and sea_level_curve[index_number]['age'] >= young_age: # add the point
			data_dict['age'] = sea_level_curve[index_number]['age']
			data_dict['calc_sl'] = sea_level_curve[index_number]['sea_level']
			check_points.append(data_dict.copy())

	# add points from the old and young ages

	for index_number in range(number_points-2):
		if sea_level_curve[index_number]['age'] < old_age and sea_level_curve[index_number+1]['age'] > old_age: # add the point

			data_dict['age'] = old_age
			data_dict['calc_sl'] = intermediate_elevation(sea_level_curve[index_number]['age'], sea_level_curve[index_number+1]['age'],sea_level_curve[index_number]['sea_level'], sea_level_curve[index_number+1]['sea_level'], old_age)
			check_points.append(data_dict.copy())


		if sea_level_curve[index_number]['age'] < young_age and sea_level_curve[index_number+1]['age'] > young_age: # add the point

			data_dict['age'] = young_age
			data_dict['calc_sl'] = intermediate_elevation(sea_level_curve[index_number]['age'], sea_level_curve[index_number+1]['age'],sea_level_curve[index_number]['sea_level'], sea_level_curve[index_number+1]['sea_level'], young_age)
			check_points.append(data_dict.copy())

	if check_points:

		found_score = True

		# marine limiting
		if data_point['indicator_type'] == -1:

			check_elevation = data_point['rsl'] - data_point['rsl_lower']


			score = 999999.0

			for point in check_points:
				temp_score = check_elevation - point['calc_sl']
				if temp_score < score:
					score = temp_score

			if score < 0:
				score = 0


		# terrestrial limiting
		elif data_point['indicator_type'] == 1:

			check_elevation = data_point['rsl'] + data_point['rsl_upper']

			score = 999999.0

			for point in check_points:
				temp_score = point['calc_sl'] - check_elevation
				if temp_score < score:
					score = temp_score

			if score < 0:
				score = 0


		# terrestrial limiting
		elif data_point['indicator_type'] == 0:

			check_elevation_upper = data_point['rsl'] + data_point['rsl_upper']
			check_elevation_lower = data_point['rsl'] - data_point['rsl_lower']

			score = 9999999.0
			for point in check_points:
				if point['calc_sl'] > check_elevation_upper:
					temp_score = point['calc_sl'] - check_elevation_upper
				elif point['calc_sl'] < check_elevation_lower:
					temp_score = check_elevation_lower - point['calc_sl']
				else:
					temp_score = 0

				if temp_score < score:
					score = temp_score

		else:
			print(f"invalid indicator type: {data_point['sample_code']}")
			found_score = False

	else:
		found_score = False

	return found_score, score


# start of program

# threshold distance, it will not extract the sea level if there isn't a calculated sea level within this distance

threshold_distance=5000

# this list contains the possible MIS stages that can be plotted right now
mis_options = ['MIS_1-2', 'MIS_3-4', 'MIS_5_a_d', 'MIS_5e' ]



calc_sl_file = sys.argv[1]
sl_file = sys.argv[2]
mis = sys.argv[3]

calculated_sea_level = pd.read_csv (calc_sl_file, sep='\s+', header=0)

latitude = calculated_sea_level['latitude'].to_numpy()
longitude = calculated_sea_level['longitude'].to_numpy()

sl_only = calculated_sea_level[calculated_sea_level.columns.difference(['latitude','longitude'])]


col_names = ["sample_code", "latitude", "longitude", "median_age", "age_uncertainty", "indicator_type", "rsl", "rsl_upper", "rsl_lower"]

data_list = pd.read_csv (sl_file, sep='\t', header=None, names=col_names)



relevant_data = []
has_data = False
for index, row in data_list.iterrows():

	if row['median_age'] <= 27000.0 and mis == "MIS_1-2":
		has_data = True
		relevant_data.append(row)
	elif row['median_age'] <= 70000.0 and row['median_age'] > 27000.0 and mis == "MIS_3-4":
		has_data = True
		relevant_data.append(row)
	elif row['median_age'] <= 115000.0 and row['median_age'] > 70000.0 and mis == "MIS_5_a_d":
		has_data = True
		relevant_data.append(row)
	elif row['median_age'] <= 135000.0 and row['median_age'] > 115000.0 and mis == "MIS_5e":
		has_data = True
		relevant_data.append(row)

sl_dict = {'age':'','sea_level':'' }



scorefile="temp/score.txt"

scoreout = open(scorefile,'wt')

if has_data:

	fileout="temp/calc_sl_curves.txt"

	fout = open(fileout,'wt')
	
	closest_index_list = []

	valid_score = True
	total_score = 0

	for data_point in relevant_data:

		# find the closest point
		closest_distance, closest_index = closest_point(latitude,longitude,data_point['latitude'],data_point['longitude'])

		if closest_index in closest_index_list:
			writeout = False
		else:
			writeout = True
			closest_index_list.append(closest_index)

		if closest_distance < threshold_distance:

			sea_level_curve = sl_only.iloc[closest_index]
			
			sea_level_curve_array = []
			for age, sea_level in sea_level_curve.iteritems():

				sl_dict['age'] = float(age)
				sl_dict['sea_level'] = float(sea_level)
				sea_level_curve_array.append(sl_dict.copy())

			sorted_sea_level_curve_array = sorted(sea_level_curve_array, key=lambda ele: ele['age'])
			if writeout:
				fout.write(">\n")
				for ts_element in sorted_sea_level_curve_array:
					fout.write(f"{ts_element['age']} {ts_element['sea_level']}\n")

			# find the score

			found_score, score = find_score(sorted_sea_level_curve_array,data_point)


			if found_score:
				total_score = total_score + score
			else:
				valid_score = false

		else:
			print(f"Warning, no calculated sea level at: {data_point['longitude']}, {data_point['latitude']}")
			valid_score = false

	fout.close()

	total_score = int(np.rint(total_score))
	if valid_score:
		
		scoreout.write(f'{total_score}')

	else:
		scoreout.write('-')

else:

	print("no relevant data")

	scoreout.write('-')
