#!/usr/bin/env python3

import sys
import csv
import numpy as np
import pandas as pd

# this program extracts calculated sea level from the file "rsl_spreadsheet.dat", which is generated by my fork of SELEN.
# This works differently than the original Fortran program that I made years ago. I changed the calculated sea level
# file so that each row represents the calculated sea level time series at a given longitude and latitude. This actually
# makes the files a lot smaller. The format is:

# longitude latitude time_0 time_1 time_2 ...


# it assumed that this program is run *after* sea_level_indicator_types.py





def closest_point(latitude_array,longitude_array, latitude, longitude):


	def distance(latitude1, longitude1, latitude2, longitude2):

		# Haversine Formula for calculating distance between two points on a sphere

		# checked against this site: https://www.movable-type.co.uk/scripts/latlong.html


		radius_earth = 6371000.0

		phi1 = np.radians(latitude1)
		phi2 = np.radians(latitude2)
		lamda1 = np.radians(longitude1)
		lamda2 = np.radians(longitude2)


		a = np.power(np.sin((phi2-phi1)/2.0),2)+np.cos(phi1) * np.cos(phi2) * np.power(np.sin((lamda2-lamda1)/2.0),2)
		c = 2.0 * np.arctan2(np.sqrt(a), np.sqrt(1.0-a))

		distance = radius_earth * c

		return distance

	distance_array = distance(latitude, longitude, latitude_array, longitude_array)
#	counter = 0
#	for distance_val in distance_array:
#		print(longitude_array[counter], latitude_array[counter], longitude, latitude, distance_val)
#		counter = counter + 1

#	sys.exit()
	closest_distance = 999999999.0
	closest_index = 0

	index = -1

	for distance in distance_array:

		index = index + 1

		if distance < closest_distance:
				closest_distance=distance
				closest_index=index
	
	return closest_distance, closest_index


# start of program

# threshold distance, it will not extract the sea level if there isn't a calculated sea level within this distance

threshold_distance=5000

# this list contains the possible MIS stages that can be plotted right now
mis_options = ['MIS_1-2', 'MIS_3-4', 'MIS_5_a_d', 'MIS_5e' ]



calc_sl_file = sys.argv[1]
sl_file = sys.argv[2]
mis = sys.argv[3]

calculated_sea_level = pd.read_csv (calc_sl_file, sep='\s+', header=0)

latitude = calculated_sea_level['latitude'].to_numpy()
longitude = calculated_sea_level['longitude'].to_numpy()

sl_only = calculated_sea_level[calculated_sea_level.columns.difference(['latitude','longitude'])]


col_names = ["sample_code", "latitude", "longitude", "median_age", "age_uncertainty", "indicator_type", "rsl", "rsl_upper", "rsl_lower"]

data_list = pd.read_csv (sl_file, sep='\t', header=None, names=col_names)



relevant_data = []
has_data = False
for index, row in data_list.iterrows():

	if row['median_age'] <= 27000.0 and mis == "MIS_1-2":
		has_data = True
		relevant_data.append(row)
	elif row['median_age'] <= 70000.0 and row['median_age'] > 27000.0 and mis == "MIS_3-4":
		has_data = True
		relevant_data.append(row)
	elif row['median_age'] <= 115000.0 and row['median_age'] > 70000.0 and mis == "MIS_5_a_d":
		has_data = True
		relevant_data.append(row)
	elif row['median_age'] <= 135000.0 and row['median_age'] > 115000.0 and mis == "MIS_5e":
		has_data = True
		relevant_data.append(row)

sl_dict = {'age':'','sea_level':'' }

if has_data:

	fileout="temp/calc_sl_curves.txt"

	fout = open(fileout,'wt')
	
	closest_index_list = []

	for data_point in relevant_data:

		# find the closest point
			closest_distance, closest_index = closest_point(latitude,longitude,data_point['latitude'],data_point['longitude'])

			if closest_index in closest_index_list:
				writeout = False
			else:
				writeout = True
				closest_index_list.append(closest_index)

			if closest_distance < threshold_distance:

				sea_level_curve = sl_only.iloc[closest_index]
				
				sea_level_curve_array = []
				for age, sea_level in sea_level_curve.iteritems():

					sl_dict['age'] = float(age)
					sl_dict['sea_level'] = float(sea_level)
					sea_level_curve_array.append(sl_dict.copy())

				sorted_sea_level_curve_array = sorted(sea_level_curve_array, key=lambda ele: ele['age'])
				if writeout:
					fout.write(">\n")
					for ts_element in sorted_sea_level_curve_array:
						fout.write(f"{ts_element['age']} {ts_element['sea_level']}\n")

				

			else:
				print(f"Warning, no calculated sea level at: {data_point['longitude']}, {data_point['latitude']}")

	fout.close()

else:
	print("no relevant data")
